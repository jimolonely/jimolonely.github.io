<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>shardingsphere on 孤独的寂寞</title><link>https://jimolonely.github.io/tags/shardingsphere/</link><description>Recent content in shardingsphere on 孤独的寂寞</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 21 May 2022 16:42:13 +0800</lastBuildDate><atom:link href="https://jimolonely.github.io/tags/shardingsphere/index.xml" rel="self" type="application/rss+xml"/><item><title>ShardingSphere proxy原理</title><link>https://jimolonely.github.io/tech/database/shardingsphere-proxy-principle/</link><pubDate>Sat, 21 May 2022 16:42:13 +0800</pubDate><guid>https://jimolonely.github.io/tech/database/shardingsphere-proxy-principle/</guid><description>代理分为前端和后端。
类 MetaDataContextsBuilder会根据配置文件构建数据的上下文，其中包括 前端和后端数据库类型。
调用流程 FrontendChannelInboundHandler
@Override public void channelRead(final ChannelHandlerContext context, final Object message) { if (!authenticated) { authenticated = authenticate(context, (ByteBuf) message); return; } ProxyStateContext.execute(context, message, databaseProtocolFrontendEngine, connectionSession); } 然后采用JDBC代理 JDBCOKProxyState，这里使用了一个异步线程去处理。
@Override public void execute(final ChannelHandlerContext context, final Object message, final DatabaseProtocolFrontendEngine databaseProtocolFrontendEngine, final ConnectionSession connectionSession) { CommandExecutorTask commandExecutorTask = new CommandExecutorTask(databaseProtocolFrontendEngine, connectionSession, context, message); ExecutorService executorService = determineSuitableExecutorService(context, databaseProtocolFrontendEngine, connectionSession); executorService.execute(commandExecutorTask); } CommandExecutorTask
private boolean executeCommand(final ChannelHandlerContext context, final PacketPayload payload) throws SQLException { CommandExecuteEngine commandExecuteEngine = databaseProtocolFrontendEngine.</description></item><item><title>ShardingSphere开发者编译指南</title><link>https://jimolonely.github.io/tech/database/shardingsphere-build-guide/</link><pubDate>Sat, 21 May 2022 09:54:43 +0800</pubDate><guid>https://jimolonely.github.io/tech/database/shardingsphere-build-guide/</guid><description>需要对接ShardingSphere（后简称SS）做一些开发，所以要编译这个庞大的项目。
环境 文档, 注意一点就是开启git的长文件名,不然clone到一半发现失败了。
git config --global core.longpaths true 编译 文档
因为SS使用了Antlr，需要全局编译才能触发Antlr插件，否则这部分代码编译不到。使用 release的profile。
mvn install -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests -Prelease 运行调试 SS的代码有200多个模块，分得非常细，我这边主要对接 proxy端，所以可以一眼发现 proxy模块。
对应的启动类位于 shardingsphere-proxy-bootstrap模块的 Bootstrap 类。
要调试的话，将 resources/conf/server.yaml 里面修改一些配置:
因为我只是本地调试其他功能，所以不需要集群模式，关于完整模式请看文档.
下面是配置SS的用户名和密码，这里配了2个用户，root和sharding。
mode: type: Memory rules: - !AUTHORITY users: - root@%:root - sharding@:sharding provider: type: ALL_PERMITTED 然后是数据源的配置，修改 conf/config-sharding.yaml:
因为这里不需要分片，所以只配了一个mysql实例，逻辑数据库名称是db，mysql里的数据库是 ds01.
databaseName: db dataSources: ds01: url: jdbc:mysql://localhost:3306/ds01 username: root password: 123456 因为需要用到mysql，这里用docker在本地起一个：
docker run --name mysql-ds01 -d -e MYSQL_DATABASE=ds01 -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql:5.</description></item></channel></rss>