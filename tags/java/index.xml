<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 孤独的寂寞</title><link>https://jimolonely.github.io/tags/java/</link><description>Recent content in java on 孤独的寂寞</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 26 May 2022 22:48:27 +0800</lastBuildDate><atom:link href="https://jimolonely.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Grpc练习</title><link>https://jimolonely.github.io/posts/java/grpc-demo/</link><pubDate>Thu, 26 May 2022 22:48:27 +0800</pubDate><guid>https://jimolonely.github.io/posts/java/grpc-demo/</guid><description>练习下Grpc使用。
proto和Service定义 src/main/proto/AgentModel.proto
模型定义2个实体，参数和返回值。
syntax = &amp;#34;proto3&amp;#34;; option java_package = &amp;#34;com.jimo.grpc&amp;#34;; message AgentInfo { string name = 1; sint32 index = 2; } message ReportResponse { bool ok = 1; string msg = 2; } src/main/proto/AgentService.proto
在服务这边就定义一个report方法。
syntax = &amp;#34;proto3&amp;#34;; option java_package = &amp;#34;com.jimo.grpc&amp;#34;; import &amp;#34;AgentModel.proto&amp;#34;; service Agent { rpc report(AgentInfo) returns (ReportResponse) {} } 编译 加入maven插件，同时编译proto文件和grpc。
&amp;lt;extensions&amp;gt; &amp;lt;extension&amp;gt; &amp;lt;groupId&amp;gt;kr.</description></item><item><title>Java instanceof List&lt;T></title><link>https://jimolonely.github.io/posts/java/java-instanceof-list/</link><pubDate>Fri, 20 May 2022 22:51:28 +0800</pubDate><guid>https://jimolonely.github.io/posts/java/java-instanceof-list/</guid><description>其实这是一个很简单的问题，在Java中，通常我们要判断一个对象是不是某种类型，会用 instanceof 关键字。
但遇到带有泛型的 List&amp;lt;T&amp;gt; 是不能直接使用，这时候怎么办呢？
我会写出下面的代码：
if(a instanceof A){ A a1 = (A)a; } if(a instanceof List &amp;amp;&amp;amp; !((List&amp;lt;?&amp;gt;)a).isEmpty() &amp;amp;&amp;amp; ((List&amp;lt;?&amp;gt;)a).get(0) instanceof A){ List&amp;lt;A&amp;gt; list = (List&amp;lt;A&amp;gt;)a; } 没问题，就是会有警告，而且这种方式在List没有元素时就不行.
另外一种方式侵入性较高，就是对List进行继承，确定一个泛型：
public class ListA extends ArrayList&amp;lt;A&amp;gt; { } ListA listA = new ListA(); listA.add(new A()); assert listA instanceof ListA; 目前还没想到更好的办法，欢迎补充。</description></item><item><title>Java Agent如何调试</title><link>https://jimolonely.github.io/posts/java/java-agent/</link><pubDate>Sat, 14 May 2022 06:51:46 +0800</pubDate><guid>https://jimolonely.github.io/posts/java/java-agent/</guid><description>做agent开发必备调试技巧：如何在IDEA里debug agent代码。
我们知道，agent一般是增强代码功能，常用的方式就是提供一个agent的jar包，应用通过 -javaagent:xxx-agent.jar这样启动。
java -javaagent:D:\agent\aweson-agent.jar -jar app.jar 使用起来简单，但开发起来就会遇到一个问题：如何调试？
总不能靠输入输出吧，当然不需要，比较IDEA还是很强大的。
先写一个简单的agent 建一个子模块 method-agent，这很重要。
我们以一个例子来演示：agent拦截类的方法，前后加入一句开始结束输出。
通过maven插件生成 MANIFEST.MF 的定义：
&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;transformers&amp;gt; &amp;lt;transformer implementation=&amp;#34;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&amp;#34;&amp;gt; &amp;lt;manifestEntries&amp;gt; &amp;lt;Premain-Class&amp;gt;com.jimo.MethodAgent&amp;lt;/Premain-Class&amp;gt; &amp;lt;!-- &amp;lt;Agent-Class&amp;gt;com.jimo.MethodAgent&amp;lt;/Agent-Class&amp;gt;--&amp;gt; &amp;lt;Can-Redefine-Classes&amp;gt;true&amp;lt;/Can-Redefine-Classes&amp;gt; &amp;lt;/manifestEntries&amp;gt; &amp;lt;/transformer&amp;gt; &amp;lt;/transformers&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; 我们只拦截自己写的类, 这里用到了 javassist 来增强类。</description></item></channel></rss>